<p></p>

## Getting our base application up and running

First, we need a base application that will generate logs. We will use a slightly modified version of a Java Spring webpage example repo (forked from [this](https://github.com/spring-guides/gs-serving-web-content)). Let's clone this modified version:

`git clone https://github.com/andreaskth/gs-serving-web-content.git`{{execute}}

*(Tip: You can click the code box to automatically enter the command in the Katacoda terminal!)*

This modified version extends the original one by adding a few HTTP endpoints (i.e. URL paths) that will spawn some logging for us to use with ELK.

To start the application, go into the recently cloned repo:

`cd gs-serving-web-content`{{execute}}

and use the Maven wrapper (`mvnw`) to trigger the installation of dependencies and start the application:

`./mvnw spring-boot:run`{{execute}}

<details>
<summary>Details of command</summary>

<div style="display: block;
  margin-left: 10px;
  margin-right: 10px;
  background-color: aliceblue;
  padding: 1em;">
The <code>mvnw</code> script in the command above is known as the Maven wrapper. Maven is a widely used build tool for Java (Gradle and Ant are popular alternatives), and the Maven wrapper is a script that can be used to avoid having to install Maven before using it.</br>
(You can read more about it <a href="https://www.baeldung.com/maven-wrapper">here</a> and <a href="https://stackoverflow.com/questions/38723833/what-is-the-purpose-of-mvnw-and-mvnw-cmd-files">here</a>).</br>
</br>
In the command above, we use the Maven wrapper to start the Spring application by passing the <code>run</code> goal to it.

</div>

</details>

This will take roughly 15 seconds the first time, since the Maven dependencies will be pulled from a central repository (these dependencies will be cached locally to make subsequent runs faster).

You will know the application has started when the terminal starts showing Spring log-messages (containing things like timestamps and green-colored `INFO` log levels).

The application is available at port 8080 of our host. To view it, click the `Base application` terminal tab. This will open up a new tab in your browser.

As you might have noticed, a Java `IllegalArgumentException` message appeared in the terminal when you opened the base application tab (if you already visited the links in the application, this message may not be visible due to other log messages appearing after it; you can still scroll up in the terminal to see it, though). This exception was raised because Katacoda automatically uses HTTPS to browse URLs, while our basic Spring application only uses HTTP ([link](https://stackoverflow.com/a/42319270)). Therefore, it's nothing to worry about. It also serves as a good reminder for the rest of the tutorial that **we can never assume that all log messages will follow the same format.**

These are some endpoints available in our base application:
* `/generate-errors` - generate 10 log messages with a log-level of `ERROR` (you can change the count by appending `/generate-errors?count=100` as a query-string)
* `/greeting` - display a 'Hello World!'-greeting page (greet someone else by appending `/greeting?name=Katacoda` as a query-string)
* `/calculator` - a simple calculator that lets the user enter numbers and basic operators through a button interface. If the equals button is pressed it does some error checking on the input expression and attempts to calculate the result. 

If you haven't already, have a go at invoking the different endpoints and look at the log-messages that appear in the Katacoda-terminal. The messages above the `IllegalArgumentException` in the output are automatically generated Spring log messages, while the messages below the exception are the log messages generated by the actions you perform in the base application. In this tutorial, we will only be interested in the latter type of messages.

Next, we will see how to make our logs persist in a log file at our chosen location. Shut down the running application (<kbd>Ctrl</kbd>+<kbd>C</kbd>, or click here: `^C`{{execute ctrl-seq}}) and proceed to the next step.
